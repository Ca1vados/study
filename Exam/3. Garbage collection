Стек и куча.
НА физическом уровне стек и куча - это хранилища памяти в ОЗУ, которые имеют разные принципы работы.

Стек:
1. Локальные переменные, аргументы функций, адреса возврата и т.д.
2. Имеет фиксированный размер (главный недостаток)
3. Не поддерживает динамическое выделение памяти
4. Легко очищается
Когда мы объявляем переменную, она попадает в Стек, когда мы покидаем область видимости переменной, стек очищается и память возвращается процессу.

Куча:
1. Глобальные переменные, ссылочный тип
2. Размер ограничен физическими характеристиками ОЗУ
3. Динамическое выделение памяти
4. Сложно в очистке

``` go
package main

import "fmt"

func main () {
    var stackVar int = 5 // попадает в стек и хранит конкретное значение, которое мы в неё положили
    var heapVar *int = new(int) // в переменную кладется указатель на определенный участок памяти, затем эта переменная также попадает в стек
    // когда мы покидаем область видимости переменных в первом случае память очищается и возвращается процессу
    // во втором пропадает указатель, но участок памяти считается занятым и, если его не освободить, оперативная память со временем просто закончится
    fmt.Println(stackVar) // 5
    fmt.Println(heapVar) // 0xc0000b2008 (адрес)
}
```

В C и C++ приходится вручную очищать память.
В go у нас есть garbage collector, который находит и удаляет неиспользуемые объекты.

Алгоритм Marc and Sweep. 2 фазы:
1. Marc - фаза разметки
Трехцветный алгоритм. Конкурентный: выполняется параллельно с основной программой.
Данные в куче рассматриваются как графи связанных объектов. Объект может быть помечен как белый, серый или черный. Изначально все объекты помечаются как белые.
Операция раскраски объекта эквивалентна его добавлению в соответствующую очередь.
а. обходим корневые объекты (объекты, которые хранятся либо в глобальной области видимости, либо в стеке нашего потока) и сканируем на наличие указателей (окрашиваем в серый цвет)
б. Найденые объекты помечаются серым цветом (помещаются в серую очередь), а исходный объект черным (помещаются в черную очередь).
в. Повторяем пока очередь серый объектов не пуста
г. Белые объекты объявляются мусором, т.к. на них не ссылаются другие элементы. Их можно удалить
2. Sweep - фаза очистки

Write barrier (мутатор)
Трехцветный алгоритм разметки выполняется параллельно с основной программой, которая называется мутатором.
Для поддержания консистентности данных в куче используется write barrier/
Основная задача барьера записи: следить за тем чтобы черные объекты не указывали на белые (это приведет к фатальномму завершению программы)
STW (stop the world) - полная остановка программы. Необходима для включения или отключения барьера записи.

Когда запускать garbage collector.
Можем вручную вызвать запуск GC с помощью функции runtime.GC().
Однако в таком случае нужно быть осторожным так как такой запуск может заблокировать вызывающую функцию или даже всю программу целиком.
По умолчанию GC запускается, когда размер кучи становится в 2 раза больше. За этим следит Pacer.
Данный коэффициент(в 2 раза) можно регулировать изменяя значение переменной среды GOGC.

Полный цикл работы GC.
1. Swap termination:
    а. STW
    б. Ожидаем пока все горутины достигнут safe-point
    в. Завершаем очистку ресурсов
2. Marc phase. Фаза разметки. Для выполнения данной фазы выделяется примерно 25% CPU. GC находится в состоянии _GCmak
    а. Включаем write barrier
    б. Start the world
    в. Запускаем сканирование глобальных переменных и стеков
    г. При сканировании стека работа горутины приостанавлявается
    д. Выполняем трехцветный алгоритм для поиска мусора.
3. Marc termination. Фаза завершения разметки. GC находится в стостоянии _GCmarktermination
    а. Stop the world
    б. Дожидаемся завершения обработки последних задач из очереди
    в. Очистка кэшей
    г. STW не обязательный
    д. Завершаем разметку
4. Sweep phase. Фаза очистки. Переходит в состояние _GCoff
    а. Отключаем write barrier
    б. Start the world
    в. Очистка ресурсов происходит в фоне.

Недостатки GC:
1. Не реализован алгоритм поколений
2. Не реализовано уплотнение
3. Подвержен фрагментации в памяти
3. STW
4. Нет возможности тонкой настройки (кроме коэффициента).

Оптимизации.
GC может стать слабым местом вашей программы, когда речь заходит о производительности. Примерно 25% CPU занимает алгоритм разметки и во время одного циклаработы дважды происходит STW.

Рекомендации для оптимизации:
1. Уменьшить количество вызовов GC с помощью изменения переменной GOGC
2. Использовать sync.Pool
3. Использовать балласт
    Балласт - это большое выделение памяти, которое уменьшает количество циклов GC на определенном промежутке времени:
    а. Увеличивает базовый размер кучи
    б. Не будет удален мусора
    в. Помечается за О(1)
    г. Выделяется в виртуальном адресном пространстве и не использует физическую память

    ~~~go
    package main
    func main() {
        //Создаем балласт размером 10gb
        ballast := make([]byte, 10<<30)
        // Код приложения...
    }
    ```

    Что такое мусор:
    указатели на некоторые данные (слайсы, мапы и то что не имееет изначально фиксируемую память(динамическое выделение памяти))
    